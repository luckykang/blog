---
layout: post
title: k8s学习01丨容器技术介绍.md
tag: k8s
---

## 一.从进程理解容器

### 1.理解几个事实

- 容器技术的兴起源于 PaaS 技术的普及；
- Docker 公司发布的 Docker 项目具有里程碑式的意义；
- Docker 项目通过“容器镜像”，解决了应用打包这个根本性难题。

### 2.进程

一旦“程序”被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。像这样一个程序运行起来后的计算机执行环境的总和，就是我们说的进程。

容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法

### 3.PID Namespace介绍

比如我们创建一个docker

    $ docker run -it busybox /bin/sh

然后容器里执行ps命令，可以看到，我们在 Docker 里最开始执行的 /bin/sh，就是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有两个进程在运行，且已经被 Docker 隔离在了一个跟宿主机完全不同的世界当中。当我们在宿主机上运行了一个 /bin/sh 程序，操作系统都会给它分配一个进程编号，比如 PID=100。这个编号是进程的唯一标识。而现在通过docker运行，对被隔离应用的进程空间做了处理，使得这些进程只能看到重新计算过的进程编号，比如PID=1，实际上他们在宿主机的操作系统里还是原来的100进程。这种机制就是Linux 里面的 Namespace 机制。

    / # ps
    PID  USER   TIME COMMAND
    1 root   0:00 /bin/sh
    10 root   0:00 ps

### 4.容器的基本实现原理

除了`PID Namespace`，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。

`Mount Namespace`，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；

`Network Namespace`，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。

**这，就是 Linux 容器最基本的实现原理了。** 实际上在创建容器进程时，制定了这个进程所需要启用的一组Namespace参数。这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。

**所以说，容器，其实是一种特殊的进程而已。**

### 5.容器和虚拟机的区别

![20211130150915](https://cdn.jsdelivr.net/gh/luckykang/picture_bed/blogs_images/20211130150915.png)

左边是虚拟机的工作原理，使用虚拟化技术作为应用沙盒，就必须要由 `Hypervisor` 来负责创建虚拟机，这个虚拟机是真实存在的，并且它里面必须运行一个完整的 Guest OS 才能执行用户的应用进程。这就不可避免地带来了额外的资源消耗和占用。

右边是docker工作原理，容器化后的用户应用，却依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器并不需要单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。

## 二.隔离与限制

### 1.`Linux Namespace` 的隔离机制有什么问题

敏捷”和“高性能”是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这种更细粒度的资源管理平台上大行其道的重要原因。不过相比于虚拟化技术也有很多不足之处，其中最主要的问题就是：**隔离得不彻底。**

- 首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。

- 其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。

- 还有是基于共享宿主机内核的事实，容器给应用暴露出来的攻击面是相当大的，应用“越狱”的难度自然也比虚拟机低得多。

### 2.为什么要对容器做限制，怎么限制？

由于容器之间是平等的竞争关系，每个容器能使用的资源可以随时被宿主机上别的容器占用，也可能吃光所有的资源，`Linux Cgroups` 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。

**Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。** 此外，Cgroups 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。在 Ubuntu可以用 mount 指令把它们展示出来，这条命令是：

    $ mount -t cgroup 
    cpuset on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
    cpu on /sys/fs/cgroup/cpu type cgroup (rw,nosuid,nodev,noexec,relatime,cpu)
    cpuacct on /sys/fs/cgroup/cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)
    blkio on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
    memory on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
    ...

输出结果，是一系列文件系统目录。`/sys/fs/cgroup` 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些都是这台机器当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：


    $ ls /sys/fs/cgroup/cpu
    cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release
    cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks

`cfs_period` 和 `cfs_quota` 这两个参数需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。

